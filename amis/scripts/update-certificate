#!/bin/bash

set -euo pipefail

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_NAME="$(basename "$0")"

readonly EC2_INSTANCE_METADATA_URL="http://169.254.169.254/latest/dynamic/instance-identity/document"

function log {
  local -r level="$1"
  local -r message="$2"
  local -r timestamp=$(date +"%Y-%m-%d %H:%M:%S")

  >&2 echo -e "${timestamp} [${level}] [$SCRIPT_NAME] ${message}"
}

function assert_not_empty {
  local -r arg_name="$1"
  local -r arg_value="$2"

  if [[ -z "$arg_value" ]]; then
    log "ERROR" "The value for '$arg_name' cannot be empty"
    exit 1
  fi
}

function lookup_metadata {
  local -r path="$1"
  curl --silent --location "$EC2_INSTANCE_METADATA_URL" | jq -r "$path"
}

get_private_ip() {
  local -r ip=$(lookup_metadata ".privateIp")
  log "INFO" "Private IP: $ip"

  echo "$ip"
}

select_vault_server() {
  local -r mine="$1"

  local -r region=$(lookup_metadata ".region")

  local -r cluster_tag="Name"
  local -r cluster_tag_vaule="vault"

  log "INFO" "Finding Vault instances in $region"

  local -r instances=$(aws ec2 describe-instances \
    --region "$region" \
    --filter "Name=tag:$cluster_tag,Values=$cluster_tag_vaule" "Name=instance-state-name,Values=running")

  local -r ip=$(echo "$instances" \
    | jq -r ".Reservations[].Instances[].PrivateIpAddress | select(. != \"$mine\")" \
    | head -n 1)

  export VAULT_ADDR="https://$ip:8200"

  if [[ -z "$VAULT_ADDR" ]]; then
    log "ERROR" "unable to find vault server"
    exit 1
  fi

  log "INFO" "Using Vault on $VAULT_ADDR"
}

login_to_vault() {
  log "INFO" "Logging into Vault"

  local -r token=$(vault login -method=aws -token-only role=generate-cert)
  export VAULT_TOKEN="$token"

  if [[ -z "$VAULT_TOKEN" ]]; then
    log "ERROR" "unable to login to vault"
    exit 1
  fi

  log "INFO" "Logged in!"
}


generate_certificate() {
  local -r tls_dir="$1"
  local -r cert_name="$2"

  local -r common_name="$3"
  local -r private_ip="$4"

  local -r ip_sans="127.0.0.1,$private_ip"

  log "INFO" "Generating a new certificate"

  local -r cert=$(vault write pki/issue/cert \
    -format=json \
    common_name="$common_name" \
    alt_names="localhost" \
    ip_sans="$ip_sans")

  echo "$cert" | jq -r .data.private_key > "$tls_dir/$cert_name.key.pem"
  echo "$cert" | jq -r .data.certificate > "$tls_dir/$cert_name.crt.pem"
  echo "$cert" | jq -r .data.issuing_ca >> "$tls_dir/$cert_name.crt.pem"

  log "INFO" "Certificate written to $tls_dir"

}


run() {
  local tls_dir="$(cd "$SCRIPT_DIR/../tls" && pwd)"
  local cert_name=""
  local common_name=""

  while [[ $# -gt 0 ]]; do
    local key="$1"

    case "$key" in
      --tls-dir)
        tls_dir="$2"
        shift
        ;;
      --cert-name)
        cert_name="$2"
        shift
        ;;
      --common-name)
        common_name="$2"
        shift
        ;;
      *)
        log "ERROR" "Unrecognized argument: $key"
        exit 1
        ;;
    esac

    shift
  done

  assert_not_empty "--tls_dir" "$tls_dir"
  assert_not_empty "--cert-name" "$cert_name"
  assert_not_empty "--common-name" "$common_name"

  local -r private_ip=$(get_private_ip)

  select_vault_server "$private_ip"
  login_to_vault

  generate_certificate \
    "$tls_dir" \
    "$cert_name" \
    "$common_name" \
    "$private_ip"

}

run "$@"
